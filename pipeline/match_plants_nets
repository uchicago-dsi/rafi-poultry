"""Contains functions to match the sales volume data of processing plants 
from Infogroup 2022 data to the FSIS dataset, based on address and location. 
"""

from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm as tqdm_progress
import pandas as pd
import numpy as np
from fuzzywuzzy import fuzz
from distances import haversine
from pathlib import Path
from constants import (CLEANED_MATCHED_PLANTS_FPATH, 
                       CLEANED_NETS_FPATH, 
                       CLEANED_FSIS_PROCESSORS_FPATH,
)

def address_match(fsis_path: Path, 
                        nets_path: Path, 
                        fuzz_ratio: float=75, 
                        num_threads: int=4):
    """Takes a cleaned FSIS and NETS dataset. Outputs a new dataset that combines the 
    NETS parent company and sales volume data with the base FSIS dataset

    Args:
        fsis_path: relative path to the clean data folder with the 
            cleaned new fsis data.
        nets_path: relative path to the clean data folder with the 
            cleaned new nets data.
        fuzz_ratio: float; minimum "fuzziness" (or similarity) score 
            to accept that two strings are "the same"; default of 75
        num_threads: int; number of simultaneous threads to run using
            multi-threading on the fuzzy matching

    Returns:
        FSIS dataset including the NETS Parent Company and Sales columns.

    """

    fsis_df = pd.read_csv(fsis_path)
    nets_df = pd.read_csv(nets_path)
    # Filter for relevant plants by looking at plants whose activity description includes poultry processing plants
    fsis_df["Activities"] = fsis_df["Activities"].str.lower()
    fsis_df = fsis_df[fsis_df["Activities"].str.contains("poultry processing")].copy()

    fsis_df["Parent Company"] = np.NaN
    fsis_df["Sales Volume (Location)"] = np.NaN

    def find_match(i, fsis_df, nets_df):
        fsis_address = fsis_df.at[i, "Full Address"].lower()
        for k, nets in nets_df.iterrows():
            nets_address = nets["ADDRESS"]
            if fuzz.token_sort_ratio(nets_address, fsis_address) > fuzz_ratio:
                return i, {
                    "Parent Company": nets["PARENT COMPANY"],
                    "Sales Volume (Location)": nets["SALESHERE"]
                }
        return i, {}

    # Create a ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        results = list(tqdm_progress(executor.map(find_match, fsis_df.index,
                                                   [fsis_df]*len(fsis_df),
                                                     [nets_df]*len(fsis_df),
                                                       chunksize=1),
                                                         total=len(fsis_df)))

    # Update the DataFrame with the results
    for i, result in results:
        if result:
            fsis_df.at[i, "Parent Company"] = result["Parent Company"]
            fsis_df.at[i, "Sales"] = result["Sales"]

    return fsis_df

def save_all_matches(nets_path: Path, 
                     fsis_path: Path, 
                     threshold: float=5) -> None:
    """Executes match function.

    Args:
        nets_path: relative path to the raw data folder 
            with the 2022 Infogroup dataset.
        fsis_path: relative path to the raw data folder with the FSIS dataset.
        threshold: threshold for maximum distance possible 
            to be considered a match.

    Returns:
        N/A, saves updated CSV to the cleaned data folder.
    """
    address_matches = address_match(nets_path, fsis_path, 75)
    address_matches.to_csv(CLEANED_MATCHED_PLANTS_FPATH)